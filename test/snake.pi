//Snake game implementation
snake = [{x: 64, y: 64}]
dir = {x: 1, y: 0}  // Initial direction: right
food = {x: floor(rand() * 127), y: floor(rand() * 120) + 7}
game_over = false
s = 8 
r = 4
speed = 8
score = 0
food_color = 1

while (!game_over) {
    clear(12)
    
    if (key('KEY_UP') && dir.y != 1) {
        dir = {x: 0, y: -1}
    }
    if (key('KEY_DOWN') && dir.y != -1) {
        dir = {x: 0, y: 1}
    }
    if (key('KEY_LEFT') && dir.x != 1) {
        dir = {x: -1, y: 0}
    }
    if (key('KEY_RIGHT') && dir.x != -1) {
        dir = {x: 1, y: 0}
    }

    let nextX = (snake[0].x + dir.x * speed + 128) % 128
    let nextY = snake[0].y + dir.y * speed

    if (nextY < 7) 
        nextY = 128 - s
    elif (nextY > 128 - s) 
        nextY = 7
    else 
        nextY = (nextY + 128) % 128

    let head = {x: nextX, y: nextY}

    // Check collision with self
    for (i in 0..len(snake)) {
        if (head.x == snake[i].x && head.y == snake[i].y) {
            game_over = true
            // ❗ Death sound (buzz)
            let s = tone(110, 200, 1)  // square wave, low pitch
            play(s);
        }
    }

    // Check if snake ate food
    let ate_food = false
    if (abs((head.x + 4) - food.x) < s && abs((head.y + 4) - food.y) < s) {
        score += 10
        food = {x: floor(rand() * 120) + 7, y: floor(rand() * 120) + 7}
        food_color = floor(rand() * 16)
        if (food_color == 12) food_color = 1
        ate_food = true

        // ✅ Eat food sound (happy blip)        
        let s = tone(660, 100, 0)  // sine wave, short high tone
        play(s);
    }

    unshift(snake, head)

    if (!ate_food) {
        pop(snake)
    }

    for (i in 0..len(snake)) {        
        let color = i % 2 == 0 ? 6 : 8
        rect(snake[i].x, snake[i].y, s, s, color, true)
    }

    circ(food.x, food.y, r, food_color, true)
    text("SCORE: " + score)

    draw()
    sleep(100)
}

// Game over screen
rect(0, 0, 128, 7, 12, true)
text(36, 56, "GAME OVER")
text(36, 72, "SCORE: " + score)
draw()
