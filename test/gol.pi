let width = 128;
let height = 128;
let board = [0] * (width * height);  // Initialize the board
let newBoard = [0] * (width * height);  // Allocate once and reuse

// Function to set the initial state of the board randomly
fun initBoard() {
    for(x in 0..width) {
        for(y in 0..height) {
            board[x + y * width] = rand() < 0.5 ? 1 : 0;
            pixel(x, y, board[x + y * width] * 6);
        }
    }
}

// Function to count live neighbors (optimized version)
fun countLiveNeighbors(x, y) {
    let count = 0;
    for(dx in -1..2) {
        for(dy in -1..2) {
            if(!(dx == 0 && dy == 0)) {
                let nx = x + dx;
                let ny = y + dy;
                if(nx >= 0 && nx < width && ny >= 0 && ny < height)
                    count += board[nx + ny * width];
            }
        }
    }
    return count;
}

// Main update function (optimized with buffer swapping)
fun update() {
    for(x in 0..width) {
        for(y in 0..height) {
            let liveNeighbors = countLiveNeighbors(x, y);
            let idx = x + y * width;
            let cell = board[idx];
            
            // Apply Game of Life rules
            if(cell == 1 && (liveNeighbors < 2 || liveNeighbors > 3))
                newBoard[idx] = 0;
            elif(cell == 0 && liveNeighbors == 3)
                newBoard[idx] = 1;
            else
                newBoard[idx] = cell;
            
            // Only update changed pixels
            if(newBoard[idx] != board[idx])
                pixel(x, y, newBoard[idx] * 6);
        }
    }
    
    // Swap buffers instead of copying
    let temp = board;
    board = newBoard;
    newBoard = temp;
}

// Initialization and loop
initBoard();

while(true) {
    update();
    draw();
}
